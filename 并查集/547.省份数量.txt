//
// 
// æœ‰ n ä¸ªåŸå¸‚ï¼Œå…¶ä¸­ä¸€äº›å½¼æ­¤ç›¸è¿ï¼Œå¦ä¸€äº›æ²¡æœ‰ç›¸è¿ã€‚å¦‚æœåŸå¸‚ a ä¸åŸå¸‚ b ç›´æ¥ç›¸è¿ï¼Œä¸”åŸå¸‚ b ä¸åŸå¸‚ c ç›´æ¥ç›¸è¿ï¼Œé‚£ä¹ˆåŸå¸‚ a ä¸åŸå¸‚ c é—´æ¥ç›¸è¿
//ã€‚ 
//
// çœä»½ æ˜¯ä¸€ç»„ç›´æ¥æˆ–é—´æ¥ç›¸è¿çš„åŸå¸‚ï¼Œç»„å†…ä¸å«å…¶ä»–æ²¡æœ‰ç›¸è¿çš„åŸå¸‚ã€‚ 
//
// ç»™ä½ ä¸€ä¸ª n x n çš„çŸ©é˜µ isConnected ï¼Œå…¶ä¸­ isConnected[i][j] = 1 è¡¨ç¤ºç¬¬ i ä¸ªåŸå¸‚å’Œç¬¬ j ä¸ªåŸå¸‚ç›´æ¥ç›¸è¿ï¼Œè€Œ 
//isConnected[i][j] = 0 è¡¨ç¤ºäºŒè€…ä¸ç›´æ¥ç›¸è¿ã€‚ 
//
// è¿”å›çŸ©é˜µä¸­ çœä»½ çš„æ•°é‡ã€‚ 
//
// 
//
// ç¤ºä¾‹ 1ï¼š 
//
// 
//è¾“å…¥ï¼šisConnected = [[1,1,0],[1,1,0],[0,0,1]]
//è¾“å‡ºï¼š2
// 
//
// ç¤ºä¾‹ 2ï¼š 
//
// 
//è¾“å…¥ï¼šisConnected = [[1,0,0],[0,1,0],[0,0,1]]
//è¾“å‡ºï¼š3
// 
//
// 
//
// æç¤ºï¼š 
//
// 
// 1 <= n <= 200 
// n == isConnected.length 
// n == isConnected[i].length 
// isConnected[i][j] ä¸º 1 æˆ– 0 
// isConnected[i][i] == 1 
// isConnected[i][j] == isConnected[j][i] 
// 
// 
// 
// Related Topics æ·±åº¦ä¼˜å…ˆæœç´¢ å¹¿åº¦ä¼˜å…ˆæœç´¢ å¹¶æŸ¥é›† å›¾ ğŸ‘ 713 ğŸ‘ 0


//leetcode submit region begin(Prohibit modification and deletion)
class UnionFind {
    //å¹¶æŸ¥é›†å’Œæ ‘æœ‰äº›ç±»ä¼¼,åªä¸è¿‡è·Ÿæ ‘ç›¸å,æ ‘ä¸­æ˜¯æ¯ä¸ªèŠ‚ç‚¹ä¼šè®°å½•å®ƒçš„å­èŠ‚ç‚¹,åœ¨å¹¶æŸ¥é›†é‡Œ,æ¯ä¸ªèŠ‚ç‚¹ä¼šè®°å½•å®ƒçš„çˆ¶èŠ‚ç‚¹
    //keyæ˜¯å½“å‰èŠ‚ç‚¹,valueæ˜¯çˆ¶èŠ‚ç‚¹
    private Map<Integer, Integer> father;
    //è®°å½•é›†åˆçš„æ•°é‡
    private int numOfSets = 0;

    public UnionFind() {
        this.father = new HashMap<>();
        this.numOfSets = 0;
    }

    /**
     * å½“æ–°èŠ‚ç‚¹æ·»åŠ åˆ°å¹¶æŸ¥é›†ä¸­ï¼Œå®ƒçš„çˆ¶èŠ‚ç‚¹åº”è¯¥ä¸ºç©º
     */
    public void add(int x) {
        if (!father.containsKey(x)) {
            father.put(x, null);
            numOfSets++;
        }
    }

    /**
     * å¦‚æœä¸¤ä¸ªèŠ‚ç‚¹æ˜¯è¿é€šçš„ï¼ˆç¥–å…ˆç›¸åŒï¼‰ï¼Œé‚£ä¹ˆå°±éœ€è¦æŠŠä»–ä»¬åˆå¹¶ï¼Œè°å½“çˆ¶èŠ‚ç‚¹æ˜¯æ²¡æœ‰åŒºåˆ«çš„
     */
    public void merge(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX != rootY) {
            father.put(rootX, rootY);
            numOfSets--;
        }
    }

    /**
     * æŸ¥æ‰¾ç¥–å…ˆ,çˆ¶èŠ‚ç‚¹ä¸ä¸ºç©ºåˆ™ä¸€ç›´è¿­ä»£
     */
    private int find(int x) {
        int root = x;
        while (father.get(root) != null) {
            root = father.get(root);
        }
        while (x != root) {
            int originalFather = father.get(x);
            father.put(x, root);
            x = originalFather;
        }
        return root;
    }

    /**
     * ä¸¤ä¸ªèŠ‚ç‚¹æ˜¯å¦ç›¸é€š,åˆ¤æ–­ä»–ä»¬çš„ç¥–å…ˆæ˜¯å¦ç›¸åŒ
     */
    public boolean isConnected(int x, int y) {
        return find(x) == find(y);
    }

    public int getNumOfSets() {
        return numOfSets;
    }

}
class Solution {
    public int findCircleNum(int[][] isConnected) {
        UnionFind uf=new UnionFind();
        for(int i=0;i<isConnected.length;i++){
            uf.add(i);
            for(int j=0;j<i;j++){
                if(isConnected[i][j]==1){
                    uf.merge(i,j);
                }
            }
        }
        return uf.getNumOfSets();
    }

}
//leetcode submit region end(Prohibit modification and deletion)
