//ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² sï¼Œè¯·ä½ å°† s åˆ†å‰²æˆä¸€äº›å­ä¸²ï¼Œä½¿æ¯ä¸ªå­ä¸²éƒ½æ˜¯ å›æ–‡ä¸² ã€‚è¿”å› s æ‰€æœ‰å¯èƒ½çš„åˆ†å‰²æ–¹æ¡ˆã€‚ 
//
// å›æ–‡ä¸² æ˜¯æ­£ç€è¯»å’Œåç€è¯»éƒ½ä¸€æ ·çš„å­—ç¬¦ä¸²ã€‚ 
//
// 
//
// ç¤ºä¾‹ 1ï¼š 
//
// 
//è¾“å…¥ï¼šs = "aab"
//è¾“å‡ºï¼š[["a","a","b"],["aa","b"]]
// 
//
// ç¤ºä¾‹ 2ï¼š 
//
// 
//è¾“å…¥ï¼šs = "a"
//è¾“å‡ºï¼š[["a"]]
// 
//
// 
//
// æç¤ºï¼š 
//
// 
// 1 <= s.length <= 16 
// s ä»…ç”±å°å†™è‹±æ–‡å­—æ¯ç»„æˆ 
// 
// Related Topics å­—ç¬¦ä¸² åŠ¨æ€è§„åˆ’ å›æº¯ 
// ğŸ‘ 1064 ğŸ‘ 0


//leetcode submit region begin(Prohibit modification and deletion)
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.List;

public class Solution {

    public List<List<String>> partition(String s) {
        int len = s.length();
        List<List<String>> res = new ArrayList<>();
        if (len == 0) {
            return res;
        }

        // Stack è¿™ä¸ªç±» Java çš„æ–‡æ¡£é‡Œæ¨èå†™æˆ Deque<Integer> stack = new ArrayDeque<Integer>();
        // æ³¨æ„ï¼šåªä½¿ç”¨ stack ç›¸å…³çš„æ¥å£
        Deque<String> stack = new ArrayDeque<>();
        char[] charArray = s.toCharArray();
        dfs(charArray, 0, len, stack, res);
        return res;
    }

    /**
     * @param charArray
     * @param index     èµ·å§‹å­—ç¬¦çš„ç´¢å¼•
     * @param len       å­—ç¬¦ä¸² s çš„é•¿åº¦ï¼Œå¯ä»¥è®¾ç½®ä¸ºå…¨å±€å˜é‡
     * @param path      è®°å½•ä»æ ¹ç»“ç‚¹åˆ°å¶å­ç»“ç‚¹çš„è·¯å¾„
     * @param res       è®°å½•æ‰€æœ‰çš„ç»“æœ
     */
    private void dfs(char[] charArray, int index, int len, Deque<String> path, List<List<String>> res) {
        if (index == len) {
            res.add(new ArrayList<>(path));
            return;
        }

        for (int i = index; i < len; i++) {
            // å› ä¸ºæˆªå–å­—ç¬¦ä¸²æ˜¯æ¶ˆè€—æ€§èƒ½çš„ï¼Œå› æ­¤ï¼Œé‡‡ç”¨ä¼ å­ä¸²ä¸‹æ ‡çš„æ–¹å¼åˆ¤æ–­ä¸€ä¸ªå­ä¸²æ˜¯å¦æ˜¯å›æ–‡å­ä¸²
            if (!checkPalindrome(charArray, index, i)) {
                continue;
            }
            path.addLast(new String(charArray, index, i + 1 - index));
            dfs(charArray, i + 1, len, path, res);
            path.removeLast();
        }
    }

    /**
     * è¿™ä¸€æ­¥çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(N)ï¼Œä¼˜åŒ–çš„è§£æ³•æ˜¯ï¼Œå…ˆé‡‡ç”¨åŠ¨æ€è§„åˆ’ï¼ŒæŠŠå›æ–‡å­ä¸²çš„ç»“æœè®°å½•åœ¨ä¸€ä¸ªè¡¨æ ¼é‡Œ
     *
     * @param charArray
     * @param left      å­ä¸²çš„å·¦è¾¹ç•Œï¼Œå¯ä»¥å–åˆ°
     * @param right     å­ä¸²çš„å³è¾¹ç•Œï¼Œå¯ä»¥å–åˆ°
     * @return
     */
    private boolean checkPalindrome(char[] charArray, int left, int right) {
        while (left < right) {
            if (charArray[left] != charArray[right]) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
}
//leetcode submit region end(Prohibit modification and deletion)
